{
  "CompMap": {
    "prefix": "CompMap",
    "body": [
      "#[derive(Debug)]",
      "pub struct CompMap<T> {",
      "    original: Vec<T>,",
      "}",
      "impl<T> CompMap<T>",
      "where",
      "    T: Clone + Ord,",
      "{",
      "    pub fn new() -> Self {",
      "        CompMap { original: vec![] }",
      "    }",
      "    pub fn push(&mut self, x: T) {",
      "        self.original.push(x);",
      "    }",
      "    pub fn push_vec(&mut self, x: &[T]) {",
      "        for i in x {",
      "            self.push(i.clone());",
      "        }",
      "    }",
      "    pub fn get(&self, x: &T) -> usize {",
      "        self.lower_bound(x)",
      "    }",
      "    pub fn get_vec(&self, x: &[T]) -> Vec<usize> {",
      "        let mut ret = vec![];",
      "        for i in x {",
      "            ret.push(self.get(i))",
      "        }",
      "        ret",
      "    }",
      "    pub fn build(&mut self) {",
      "        self.original.sort();",
      "        self.original.dedup();",
      "    }",
      "    fn lower_bound(&self, x: &T) -> usize {",
      "        let n = self.original.len();",
      "        let mut ng = -1;",
      "        let mut ok = n as isize;",
      "        while ok - ng > 1 {",
      "            let mid = (ok + ng) / 2;",
      "            if *x <= self.original[mid as usize] {",
      "                ok = mid;",
      "            } else {",
      "                ng = mid;",
      "            }",
      "        }",
      "        ok as usize",
      "    }",
      "}",
      "impl<T> Default for CompMap<T>",
      "where",
      "    T: Clone + Ord,",
      "{",
      "    fn default() -> Self {",
      "        Self::new()",
      "    }",
      "}"
    ]
  },
  "LazySegtree": {
    "prefix": "LazySegtree",
    "body": [
      "pub trait ForLazySegtree {",
      "    /// セグ木に乗せるモノイド",
      "    type M: Monoid;",
      "    /// Lazyに乗せるモノイド",
      "    type L: Monoid;",
      "    /// モノイドMに対して、Lをどう作用させるか",
      "    fn mapping(m: &<Self::M as Monoid>::S, l: &<Self::L as Monoid>::S) -> <Self::M as Monoid>::S;",
      "}",
      "pub struct LazySegtree<T: ForLazySegtree> {",
      "    original_size: usize,",
      "    leaf_size: usize,",
      "    node: Vec<<T::M as Monoid>::S>,",
      "    lazy: Vec<<T::L as Monoid>::S>,",
      "}",
      "impl<T: ForLazySegtree> LazySegtree<T> {",
      "    pub fn new(n: usize) -> Self {",
      "        let size = n.next_power_of_two();",
      "        LazySegtree {",
      "            original_size: n,",
      "            leaf_size: size,",
      "            node: vec![T::M::e(); 2 * size],",
      "            lazy: vec![T::L::e(); 2 * size],",
      "        }",
      "    }",
      "    fn next_op(&self, i: usize) -> <T::M as Monoid>::S {",
      "        T::M::op(&self.node[i << 1], &self.node[i << 1 | 1])",
      "    }",
      "    pub fn build(&mut self, vec: &[<T::M as Monoid>::S]) {",
      "        for (i, ele) in vec.iter().enumerate() {",
      "            let idx = i + self.leaf_size;",
      "            self.node[idx] = ele.clone();",
      "        }",
      "        for i in (1..self.leaf_size).rev() {",
      "            self.node[i] = self.next_op(i);",
      "        }",
      "    }",
      "    pub fn update(&mut self, i: usize, x: <T::M as Monoid>::S) {",
      "        //! 一点更新 O(log N)",
      "        assert!(i < self.original_size);",
      "        let i = i + self.leaf_size;",
      "        self.propagate_above(i);",
      "        self.node[i] = x;",
      "        self.lazy[i] = T::L::e();",
      "        self.recalc_above(i);",
      "    }",
      "    fn range_to_tuple<R>(range: R, r_max: usize) -> (usize, usize)",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        use std::ops::Bound;",
      "        let l = match range.start_bound() {",
      "            Bound::Included(l) => *l,",
      "            Bound::Excluded(l) => l + 1,",
      "            Bound::Unbounded => 0,",
      "        };",
      "        let r = match range.end_bound() {",
      "            Bound::Included(r) => r + 1,",
      "            Bound::Excluded(r) => *r,",
      "            Bound::Unbounded => r_max,",
      "        };",
      "        (l, r)",
      "    }",
      "    pub fn fold<R>(&mut self, range: R) -> <T::M as Monoid>::S",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        //! 区間取得 O(log N)",
      "        let (l, r) = Self::range_to_tuple(range, self.original_size);",
      "        assert!(l < self.original_size);",
      "        assert!(r <= self.original_size);",
      "        let mut l = l + self.leaf_size;",
      "        let mut r = r + self.leaf_size;",
      "        self.propagate_above(l / (l & (!l + 1)));",
      "        self.propagate_above((r / (r & (!r + 1))) - 1);",
      "        let mut vl = T::M::e();",
      "        let mut vr = T::M::e();",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                vl = T::M::op(&vl, &self.eval_at(l));",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                vr = T::M::op(&self.eval_at(r), &vr)",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        T::M::op(&vl, &vr)",
      "    }",
      "    pub fn apply_range<R>(&mut self, range: R, a: <T::L as Monoid>::S)",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        //! 区間作用 O(log N)",
      "        let (l, r) = Self::range_to_tuple(range, self.original_size);",
      "        let mut l = l + self.leaf_size;",
      "        let mut r = r + self.leaf_size;",
      "        let l0 = l / (l & (!l + 1));",
      "        let r0 = (r / (r & (!r + 1))) - 1;",
      "        self.propagate_above(l0);",
      "        self.propagate_above(r0);",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                self.lazy[l] = T::L::op(&self.lazy[l], &a);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                self.lazy[r] = T::L::op(&self.lazy[r], &a);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        self.recalc_above(l0);",
      "        self.recalc_above(r0);",
      "    }",
      "    pub fn max_right<F>(&mut self, l: usize, f: F) -> usize",
      "    where",
      "        F: Fn(&<T::M as Monoid>::S) -> bool,",
      "    {",
      "        //! `f(l..r) == true`となる最大のrを探索",
      "        assert!(l <= self.original_size);",
      "        assert!(f(&T::M::e()));",
      "        let mut l = l + self.leaf_size;",
      "        let mut v = T::M::e();",
      "        self.propagate_above(l / (l & (!l + 1)));",
      "        loop {",
      "            while l & 1 != 1 {",
      "                l >>= 1;",
      "            }",
      "            if !f(&T::M::op(&v, &self.node[l])) {",
      "                while l < self.leaf_size {",
      "                    self.propagate_at(l);",
      "                    l <<= 1;",
      "                    if f(&T::M::op(&v, &self.node[l])) {",
      "                        v = T::M::op(&v, &self.node[l]);",
      "                        l += 1;",
      "                    }",
      "                }",
      "                return l - self.leaf_size;",
      "            }",
      "            v = T::M::op(&v, &self.node[l]);",
      "            l += 1;",
      "            {",
      "                let l = l as isize;",
      "                if l & -l == l {",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "        self.original_size",
      "    }",
      "    pub fn min_left<F>(&mut self, r: usize, f: F) -> usize",
      "    where",
      "        F: Fn(&<T::M as Monoid>::S) -> bool,",
      "    {",
      "        //! `f(l..r) == true`となる最小のlを探索",
      "        assert!(r <= self.original_size);",
      "        assert!(f(&T::M::e()));",
      "        let mut r = r + self.leaf_size;",
      "        let mut v = T::M::e();",
      "        self.propagate_above((r / (r & (!r + 1))) - 1);",
      "        loop {",
      "            r -= 1;",
      "            while r > 1 && r & 1 == 1 {",
      "                r >>= 1;",
      "            }",
      "            if !f(&T::M::op(&self.node[r], &v)) {",
      "                while r < self.leaf_size {",
      "                    self.propagate_at(r);",
      "                    r <<= 1;",
      "                    r += 1;",
      "                    if f(&T::M::op(&self.node[r], &v)) {",
      "                        v = T::M::op(&self.node[r], &v);",
      "                        r -= 1;",
      "                    }",
      "                }",
      "                return r + 1 - self.leaf_size;",
      "            }",
      "            v = T::M::op(&self.node[r], &v);",
      "            {",
      "                let r = r as isize;",
      "                if r & -r == r {",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "        0",
      "    }",
      "}",
      "impl<T: ForLazySegtree> LazySegtree<T> {",
      "    fn eval_at(&mut self, i: usize) -> <T::M as Monoid>::S {",
      "        //! node[i]にlazy[i]を作用",
      "        T::mapping(&self.node[i], &self.lazy[i])",
      "    }",
      "    fn propagate_at(&mut self, i: usize) {",
      "        //! lazyの合成",
      "        //! 非可換を想定しているので、lazy[i]にあるLをnode[i]に作用させる",
      "        self.node[i] = self.eval_at(i);",
      "        self.lazy[i << 1] = T::L::op(&self.lazy[i << 1], &self.lazy[i]);",
      "        self.lazy[i << 1 | 1] = T::L::op(&self.lazy[i << 1 | 1], &self.lazy[i]);",
      "        self.lazy[i] = T::L::e();",
      "    }",
      "    fn propagate_above(&mut self, i: usize) {",
      "        let h = std::usize::MAX.count_ones() - i.leading_zeros();",
      "        for k in (1..h).rev() {",
      "            self.propagate_at(i >> k);",
      "        }",
      "    }",
      "    fn recalc_above(&mut self, i: usize) {",
      "        let mut i = i;",
      "        while i > 1 {",
      "            i >>= 1;",
      "            self.node[i] = T::M::op(&self.eval_at(i << 1), &self.eval_at(i << 1 | 1))",
      "        }",
      "    }",
      "}"
    ]
  },
  "Monoid": {
    "prefix": "Monoid",
    "body": [
      "pub trait Monoid {",
      "    type S: Clone;",
      "    fn op(left: &Self::S, right: &Self::S) -> Self::S;",
      "    fn e() -> Self::S;",
      "}"
    ]
  },
  "NRadixFrom": {
    "prefix": "NRadixFrom",
    "body": [
      "pub trait NRadixFrom {",
      "    /// 10進法から任意の進法へのコンバート",
      "    /// n進法から10進法へは、from_str_radixを使う",
      "    fn n_radix_from(&self, n: u64) -> Vec<u64>;",
      "}",
      "impl NRadixFrom for String {",
      "    fn n_radix_from(&self, n: u64) -> Vec<u64> {",
      "        self.chars().collect::<Vec<char>>().n_radix_from(n)",
      "    }",
      "}",
      "impl NRadixFrom for &str {",
      "    fn n_radix_from(&self, n: u64) -> Vec<u64> {",
      "        self.chars().collect::<Vec<char>>().n_radix_from(n)",
      "    }",
      "}",
      "impl NRadixFrom for [char] {",
      "    fn n_radix_from(&self, n: u64) -> Vec<u64> {",
      "        let mut a = 0;",
      "        for c in self.iter() {",
      "            a *= 10;",
      "            a += c.to_digit(10).unwrap() as usize;",
      "        }",
      "        a.n_radix_from(n)",
      "    }",
      "}",
      "impl NRadixFrom for usize {",
      "    fn n_radix_from(&self, n: u64) -> Vec<u64> {",
      "        let x = self.clone() as u64;",
      "        x.n_radix_from(n)",
      "    }",
      "}",
      "impl NRadixFrom for u8 {",
      "    fn n_radix_from(&self, n: u64) -> Vec<u64> {",
      "        let x = self.clone() as usize;",
      "        x.n_radix_from(n)",
      "    }",
      "}",
      "impl NRadixFrom for u16 {",
      "    fn n_radix_from(&self, n: u64) -> Vec<u64> {",
      "        let x = self.clone() as usize;",
      "        x.n_radix_from(n)",
      "    }",
      "}",
      "impl NRadixFrom for u32 {",
      "    fn n_radix_from(&self, n: u64) -> Vec<u64> {",
      "        let x = self.clone() as usize;",
      "        x.n_radix_from(n)",
      "    }",
      "}",
      "impl NRadixFrom for u64 {",
      "    fn n_radix_from(&self, n: u64) -> Vec<u64> {",
      "        let mut ret = vec![];",
      "        let mut x = self.clone();",
      "        let n = n as u64;",
      "        while 0 < x {",
      "            let t = x % n;",
      "            ret.push(t);",
      "            x /= n;",
      "        }",
      "        ret.reverse();",
      "        ret",
      "    }",
      "}",
      "impl NRadixFrom for u128 {",
      "    fn n_radix_from(&self, n: u64) -> Vec<u64> {",
      "        let n = n as u128;",
      "        let mut ret = vec![];",
      "        let mut x = self.clone();",
      "        while 0 < x {",
      "            let t = x % n;",
      "            ret.push(t as u64);",
      "            x /= n;",
      "        }",
      "        ret.reverse();",
      "        ret",
      "    }",
      "}"
    ]
  },
  "Scc": {
    "prefix": "Scc",
    "body": [
      "/// 強連結成分分解を行う",
      "/// `O(|V| + |E|)`",
      "pub struct Scc {",
      "    g: Vec<Vec<usize>>,",
      "    rg: Vec<Vec<usize>>,",
      "    kaerigake: std::cell::RefCell<Vec<usize>>,",
      "    pub dag: Vec<Vec<usize>>,",
      "    pub group_vs: Vec<Vec<usize>>,",
      "}",
      "impl Scc {",
      "    pub fn new(g: Vec<Vec<usize>>) -> Self {",
      "        let mut rg = vec![vec![]; g.len()];",
      "        for v in 0..g.len() {",
      "            for &nv in &g[v] {",
      "                rg[nv].push(v);",
      "            }",
      "        }",
      "        Scc {",
      "            g,",
      "            rg,",
      "            kaerigake: std::cell::RefCell::new(vec![]),",
      "            dag: vec![],",
      "            group_vs: vec![],",
      "        }",
      "    }",
      "    fn dfs(&self, st: usize, seen: &mut Vec<bool>) {",
      "        seen[st] = true;",
      "        for &nv in &self.g[st] {",
      "            if seen[nv] {",
      "                continue;",
      "            }",
      "            self.dfs(nv, seen);",
      "        }",
      "        self.kaerigake.borrow_mut().push(st);",
      "    }",
      "    fn rdfs(&self, st: usize, seen: &mut Vec<bool>, group: &mut Vec<usize>, cnt: usize) {",
      "        seen[st] = true;",
      "        group[st] = cnt;",
      "        for &nv in &self.rg[st] {",
      "            if seen[nv] {",
      "                continue;",
      "            }",
      "            self.rdfs(nv, seen, group, cnt);",
      "        }",
      "    }",
      "    pub fn scc(&mut self) {",
      "        let mut seen = vec![false; self.g.len()];",
      "        for v in 0..self.g.len() {",
      "            if seen[v] {",
      "                continue;",
      "            }",
      "            self.dfs(v, &mut seen);",
      "        }",
      "        seen.fill(false);",
      "        let mut group = vec![usize::MAX; self.g.len()];",
      "        let mut cnt = 0;",
      "        for &v in self.kaerigake.borrow().iter().rev() {",
      "            if seen[v] {",
      "                continue;",
      "            }",
      "            self.rdfs(v, &mut seen, &mut group, cnt);",
      "            cnt += 1;",
      "        }",
      "        self.dag = vec![vec![]; cnt];",
      "        self.group_vs = vec![vec![]; cnt];",
      "        for v in 0..self.g.len() {",
      "            self.group_vs[group[v]].push(v);",
      "            for &nv in &self.g[v] {",
      "                if group[v] == group[nv] {",
      "                    continue;",
      "                }",
      "                self.dag[group[v]].push(group[nv]);",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "Segtree": {
    "prefix": "Segtree",
    "body": [
      "#[derive(Debug)]",
      "pub struct Segtree<T>",
      "where",
      "    T: Monoid,",
      "{",
      "    original_size: usize,",
      "    leaf_size: usize,",
      "    node: Vec<T::S>,",
      "}",
      "impl<T> Segtree<T>",
      "where",
      "    T: Monoid,",
      "{",
      "    pub fn new(n: usize) -> Self {",
      "        let exp = {",
      "            let mut ok: i64 = 41;",
      "            let mut ng: i64 = -1;",
      "            while (ok - ng).abs() > 1 {",
      "                let mid = (ok + ng) / 2;",
      "                if 1 << mid >= n {",
      "                    ok = mid;",
      "                } else {",
      "                    ng = mid;",
      "                }",
      "            }",
      "            ok",
      "        };",
      "        let size = 1 << exp;",
      "        Segtree {",
      "            original_size: n,",
      "            leaf_size: size,",
      "            node: vec![T::e(); 2 * size],",
      "        }",
      "    }",
      "    pub fn build(&mut self, vec: &[T::S]) {",
      "        for (i, ele) in vec.iter().enumerate() {",
      "            let idx = i + self.leaf_size;",
      "            self.node[idx] = ele.clone();",
      "        }",
      "        for i in (1..self.leaf_size).rev() {",
      "            self.node[i] = self.nex_op(i);",
      "        }",
      "    }",
      "    pub fn update(&mut self, i: usize, x: T::S) {",
      "        //! 一点更新 O(logN)",
      "        let mut idx = i + self.leaf_size;",
      "        self.node[idx] = x;",
      "        while idx > 1 {",
      "            idx >>= 1;",
      "            self.node[idx] = self.nex_op(idx);",
      "        }",
      "    }",
      "    fn nex_op(&self, i: usize) -> T::S {",
      "        T::op(&self.node[i << 1], &self.node[i << 1 | 1])",
      "    }",
      "    pub fn add(&mut self, idx: usize, x: &T::S) {",
      "        //! 一点に`x`との二項演算 O(log N)",
      "        let mut idx = idx + self.leaf_size;",
      "        self.node[idx] = T::op(&self.node[idx], x);",
      "        while idx > 1 {",
      "            idx >>= 1;",
      "            self.node[idx] = self.nex_op(idx);",
      "        }",
      "    }",
      "    fn range_to_tuple<R>(range: R, r_max: usize) -> (usize, usize)",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        use std::ops::Bound;",
      "        let l = match range.start_bound() {",
      "            Bound::Included(l) => *l,",
      "            Bound::Excluded(l) => l + 1,",
      "            Bound::Unbounded => 0,",
      "        };",
      "        let r = match range.end_bound() {",
      "            Bound::Included(r) => r + 1,",
      "            Bound::Excluded(r) => *r,",
      "            Bound::Unbounded => r_max,",
      "        };",
      "        (l, r)",
      "    }",
      "    pub fn fold<R>(&self, range: R) -> T::S",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        //! 区間取得 O(logN)",
      "        let (l, r) = Self::range_to_tuple(range, self.original_size);",
      "        self.query(l, r)",
      "    }",
      "    fn query(&self, l: usize, r: usize) -> T::S {",
      "        assert!(l < self.original_size);",
      "        assert!(1 <= r && r <= self.original_size);",
      "        let mut l = l + self.leaf_size;",
      "        let mut r = r + self.leaf_size;",
      "        let mut vl = T::e();",
      "        let mut vr = T::e();",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                vl = T::op(&vl, &self.node[l].clone());",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                vr = T::op(&self.node[r], &vr);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        T::op(&vl, &vr)",
      "    }",
      "    pub fn get(&self, idx: usize) -> &T::S {",
      "        &self.node[idx + self.leaf_size]",
      "    }",
      "    pub fn max_right<F>(&self, mut l: usize, f: F) -> usize",
      "    where",
      "        F: Fn(&T::S) -> bool,",
      "    {",
      "        //! `f(l..r) == true`となる最大のrを探索",
      "        assert!(l <= self.original_size);",
      "        assert!(f(&T::e()));",
      "        l += self.leaf_size;",
      "        let mut v = T::e();",
      "        loop {",
      "            while l & 1 != 1 {",
      "                l >>= 1;",
      "            }",
      "            if !f(&T::op(&v, &self.node[l])) {",
      "                while l < self.leaf_size {",
      "                    l <<= 1;",
      "                    if f(&T::op(&v, &self.node[l])) {",
      "                        v = T::op(&v, &self.node[l]);",
      "                        l += 1;",
      "                    }",
      "                }",
      "                return l - self.leaf_size;",
      "            }",
      "            v = T::op(&v, &self.node[l]);",
      "            l += 1;",
      "            {",
      "                let l = l as isize;",
      "                if l & -l == l {",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "        self.original_size",
      "    }",
      "    pub fn min_left<F>(&self, mut r: usize, f: F) -> usize",
      "    where",
      "        F: Fn(&T::S) -> bool,",
      "    {",
      "        //! `f(l..r) == true`となる最小のlを探索",
      "        assert!(r <= self.original_size);",
      "        assert!(f(&T::e()));",
      "        r += self.leaf_size;",
      "        let mut v = T::e();",
      "        loop {",
      "            r -= 1;",
      "            while r > 1 && r & 1 == 1 {",
      "                r >>= 1;",
      "            }",
      "            if !f(&T::op(&self.node[r], &v)) {",
      "                while r < self.leaf_size {",
      "                    r <<= 1;",
      "                    r += 1;",
      "                    if f(&T::op(&self.node[r], &v)) {",
      "                        v = T::op(&self.node[r], &v);",
      "                        r -= 1;",
      "                    }",
      "                }",
      "                return r + 1 - self.leaf_size;",
      "            }",
      "            v = T::op(&self.node[r], &v);",
      "            {",
      "                let r = r as isize;",
      "                if r & -r == r {",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "        0",
      "    }",
      "}"
    ]
  },
  "Trie": {
    "prefix": "Trie",
    "body": [
      "#[derive(Debug, Clone)]",
      "struct TrieNode {",
      "    vertex: Option<char>,",
      "    is_finished: bool,",
      "    common: usize,",
      "    next_verts: std::collections::HashMap<char, TrieNode>,",
      "}",
      "impl TrieNode {",
      "    fn new(c: char, is_finished: bool) -> TrieNode {",
      "        TrieNode {",
      "            vertex: Some(c),",
      "            is_finished,",
      "            common: 0,",
      "            next_verts: std::collections::HashMap::new(),",
      "        }",
      "    }",
      "    fn new_root() -> TrieNode {",
      "        TrieNode {",
      "            vertex: None,",
      "            is_finished: false,",
      "            common: 0,",
      "            next_verts: std::collections::HashMap::new(),",
      "        }",
      "    }",
      "}",
      "#[derive(Debug, Clone)]",
      "pub struct Trie {",
      "    root: TrieNode,",
      "}",
      "impl Trie {",
      "    pub fn new() -> Trie {",
      "        Trie {",
      "            root: TrieNode::new_root(),",
      "        }",
      "    }",
      "    pub fn abc353e(&self, vc: &[char]) -> usize {",
      "        let mut ret = 0;",
      "        let mut current_node = &self.root;",
      "        for c in vc {",
      "            if current_node.next_verts.contains_key(c) {",
      "                current_node = current_node.next_verts.get(c).unwrap();",
      "                eprintln!(\"{:?}: {}\", current_node.vertex, current_node.common);",
      "                ret += current_node.common;",
      "            } else {",
      "                break;",
      "            }",
      "        }",
      "        ret",
      "    }",
      "    pub fn insert(&mut self, vc: &[char]) {",
      "        let mut current_node = &mut self.root;",
      "        for c in vc {",
      "            current_node.common += 1;",
      "            if current_node.next_verts.contains_key(c) {",
      "                current_node = current_node.next_verts.get_mut(c).unwrap();",
      "            } else {",
      "                current_node.next_verts.insert(*c, TrieNode::new(*c, false));",
      "                current_node = current_node.next_verts.get_mut(c).unwrap();",
      "            }",
      "        }",
      "        current_node.common += 1;",
      "        current_node.is_finished = true;",
      "    }",
      "    pub fn contains(&mut self, vc: &[char]) -> bool {",
      "        let mut current_node = &mut self.root;",
      "        for c in vc {",
      "            if current_node.next_verts.contains_key(c) {",
      "                current_node = current_node.next_verts.get_mut(c).unwrap();",
      "            } else {",
      "                return false;",
      "            }",
      "        }",
      "        true",
      "    }",
      "    pub fn lcp(&mut self, vc: &[char]) -> usize {",
      "        let mut current_node = &mut self.root;",
      "        let mut ret = 0;",
      "        for c in vc {",
      "            if current_node.next_verts.contains_key(c) {",
      "                current_node = current_node.next_verts.get_mut(c).unwrap();",
      "                if current_node.common >= 2 {",
      "                    ret += 1",
      "                } else {",
      "                    break;",
      "                }",
      "            } else {",
      "                break;",
      "            }",
      "        }",
      "        ret",
      "    }",
      "}",
      "impl Default for Trie {",
      "    fn default() -> Self {",
      "        Self::new()",
      "    }",
      "}"
    ]
  },
  "UnionFind": {
    "prefix": "UnionFind",
    "body": [
      "pub struct UnionFind {",
      "    len: usize,",
      "    par: Vec<usize>,",
      "    size: Vec<usize>,",
      "}",
      "impl UnionFind {",
      "    pub fn new(n: usize) -> Self {",
      "        UnionFind {",
      "            len: n,",
      "            par: (0..n).collect(),",
      "            size: vec![1; n],",
      "        }",
      "    }",
      "    pub fn root(&mut self, x: usize) -> usize {",
      "        if self.par[x] == x {",
      "            x",
      "        } else {",
      "            self.par[x] = self.root(self.par[x]);",
      "            self.par[x]",
      "        }",
      "    }",
      "    pub fn unite(&mut self, x: usize, y: usize) -> bool {",
      "        let mut x = self.root(x);",
      "        let mut y = self.root(y);",
      "        if x == y {",
      "            return false;",
      "        }",
      "        if self.size[x] < self.size[y] {",
      "            std::mem::swap(&mut x, &mut y);",
      "        }",
      "        self.par[y] = x;",
      "        self.size[x] += self.size[y];",
      "        true",
      "    }",
      "    pub fn issame(&mut self, x: usize, y: usize) -> bool {",
      "        if self.root(x) == self.root(y) {",
      "            return true;",
      "        }",
      "        false",
      "    }",
      "    pub fn size(&mut self, x: usize) -> usize {",
      "        let r = self.root(x);",
      "        self.size[r]",
      "    }",
      "    pub fn group_count(&mut self) -> usize {",
      "        //!  `UnionFind`内の集合の数を返す",
      "        //! `O(Nα(N)) `",
      "        let mut cnt = vec![0; self.len];",
      "        for i in 0..self.len {",
      "            cnt[self.root(i)] += 1;",
      "        }",
      "        cnt.iter().filter(|&&i| 0 < i).count()",
      "    }",
      "}"
    ]
  },
  "bellman_ford": {
    "prefix": "bellman_ford",
    "body": [
      "pub fn bellman_ford(st: usize, g: &[Vec<(isize, usize)>]) -> Vec<isize> {",
      "    //! `st`からの単一始点最短路を返す",
      "    //! `(cost, nv)`の隣接リストを要求",
      "    //! 不閉路になるものは`-inf`にして返す",
      "    //! `O(|V| |E|)`",
      "    let n = g.len();",
      "    const INF: isize = isize::MAX;",
      "    const NEG_INF: isize = isize::MIN;",
      "    let mut dist = vec![INF; n];",
      "    dist[st] = 0;",
      "    for _ in 0..n - 1 {",
      "        for v in 0..n {",
      "            if dist[v] == INF {",
      "                continue;",
      "            }",
      "            for (c, nv) in &g[v] {",
      "                if dist[*nv] > dist[v] + c {",
      "                    dist[*nv] = dist[v] + c",
      "                }",
      "            }",
      "        }",
      "    }",
      "    for _ in 0..n {",
      "        for v in 0..n {",
      "            for (c, nv) in &g[v] {",
      "                if dist[*nv] == INF {",
      "                    continue;",
      "                }",
      "                if dist[*nv] > dist[v] + c {",
      "                    dist[*nv] = NEG_INF",
      "                }",
      "            }",
      "        }",
      "    }",
      "    dist",
      "}"
    ]
  },
  "bfs": {
    "prefix": "bfs",
    "body": [
      "pub fn bfs(st: usize, g: &[Vec<usize>]) -> Vec<isize> {",
      "    let n = g.len();",
      "    let mut dist: Vec<isize> = vec![-1; n];",
      "    let mut q = std::collections::VecDeque::new();",
      "    q.push_back(st);",
      "    dist[st] = 0;",
      "    while let Some(v) = q.pop_front() {",
      "        for nv in &g[v] {",
      "            if dist[*nv] != -1 {",
      "                continue;",
      "            }",
      "            dist[*nv] = dist[v] + 1;",
      "            q.push_back(*nv);",
      "        }",
      "    }",
      "    dist",
      "}"
    ]
  },
  "dfs": {
    "prefix": "dfs",
    "body": [
      "pub fn dfs(v: usize, p: usize, g: &[Vec<usize>]) {",
      "    for nv in &g[v] {",
      "        if p == *nv {",
      "            continue;",
      "        }",
      "        dfs(*nv, p, g);",
      "    }",
      "}"
    ]
  },
  "dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "pub fn dijkstra(st: usize, g: &[Vec<(usize, usize)>]) -> Vec<usize> {",
      "    //! 単一始点最短路を求める",
      "    //! `(cost, nv)`の隣接リストを要求",
      "    //! `O(|E|log|V|)`",
      "    use std::cmp::Reverse;",
      "    let n = g.len();",
      "    let inf: usize = 1 << 60;",
      "    let mut kakutei = vec![false; n];",
      "    let mut dist = vec![inf; n];",
      "    let mut pq = std::collections::BinaryHeap::new();",
      "    dist[st] = 0;",
      "    pq.push(Reverse((dist[st], st)));",
      "    while let Some(Reverse((_, v))) = pq.pop() {",
      "        if kakutei[v] {",
      "            continue;",
      "        }",
      "        kakutei[v] = true;",
      "        for (ncos, nv) in &g[v] {",
      "            if dist[*nv] > dist[v] + ncos {",
      "                dist[*nv] = dist[v] + ncos;",
      "                pq.push(Reverse((dist[*nv], *nv)))",
      "            }",
      "        }",
      "    }",
      "    dist",
      "}"
    ]
  },
  "kruskal": {
    "prefix": "kruskal",
    "body": [
      "pub fn kruskal(mut e: Vec<(isize, usize, usize)>, n: usize) -> (Vec<(isize, usize, usize)>, isize) {",
      "    //! 最小全域木に入る辺と両端点、総コストを返す",
      "    //! `(cost, v, nv)`の隣接リスト",
      "    //! `O(|E|log|E|)`",
      "    e.sort();",
      "    let mut uf = UnionFind::new(n);",
      "    let mut ans_cost = 0;",
      "    let mut ans_e = vec![];",
      "    for (c, v, u) in e {",
      "        if uf.issame(v, u) {",
      "            continue;",
      "        }",
      "        uf.unite(v, u);",
      "        ans_cost += c;",
      "        ans_e.push((c, v, u));",
      "    }",
      "    (ans_e, ans_cost)",
      "}"
    ]
  },
  "lcm/gcd": {
    "prefix": "lcm/gcd",
    "body": [
      "pub fn gcd(a: usize, b: usize) -> usize {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "pub fn lcm(a: usize, b: usize) -> usize {",
      "    (a / gcd(a, b)) * b",
      "}"
    ]
  },
  "modinv": {
    "prefix": "modinv",
    "body": [
      "pub fn modinv(mut a: isize, m: isize) -> isize {",
      "    //! `a mod m`の逆元",
      "    //! `a`と`m`の互いが素を仮定",
      "    let mut b = m;",
      "    let mut u = 1;",
      "    let mut v = 0;",
      "    while b > 0 {",
      "        let t = a.div_euclid(b);",
      "        a -= t * b;",
      "        (a, b) = (b, a);",
      "        u -= t * v;",
      "        (u, v) = (v, u);",
      "    }",
      "    u = u.rem_euclid(m);",
      "    u",
      "}"
    ]
  },
  "warshall_froyd": {
    "prefix": "warshall_froyd",
    "body": [
      "pub fn warshall_froyd(g: &[Vec<(isize, usize)>]) {",
      "    //! 全始点最短路",
      "    //! `(cost, nv)`のの隣接リスト",
      "    //! `O(|V|^3)`",
      "    const INF: isize = isize::MAX;",
      "    let n = g.len();",
      "    let mut dist = vec![vec![INF; g.len()]; g.len()];",
      "    for v in 0..n {",
      "        for &(cost, nv) in &g[v] {",
      "            dist[v][nv] = isize::min(dist[v][nv], cost);",
      "        }",
      "    }",
      "    for k in 0..n {",
      "        for i in 0..n {",
      "            for j in 0..n {",
      "                dist[i][j] = dist[i][j].min(dist[i][k] + dist[k][j])",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  }
}
