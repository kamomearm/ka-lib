# kamome_armの競技プログラミング用ライブラリ

## 方針
- `cargo_snippet`を使用して、スニペットとして管理する

## 改善点
- `trait`等を使ってより汎用性を高めたい
    - スニペットとして管理することを考えたら、やりにくい気もする
        - `#[snippet(include = "")]`を使用するとインクルード先が被ったときに、削除するのは大変そう
        - `trait`類はあらかじめコードに書いておいて、`#[snippet(include = "")]`はなるべく使わないとする？
    - 命名規則がはっきりとしていない
    - ドキュメントの体裁もバラバラなので直したい
    - `test`全然書いてない


  "CompMap": {
    "prefix": "CompMap",
    "body": [
      "#[derive(Debug)]",
      "pub struct CompMap<T> {",
      "    original: Vec<T>,",
      "}",
      "impl<T> CompMap<T>",
      "where",
      "    T: Clone + Ord,",
      "{",
      "    pub fn new() -> Self {",
      "        CompMap { original: vec![] }",
      "    }",
      "    pub fn push(&mut self, x: T) {",
      "        self.original.push(x);",
      "    }",
      "    pub fn push_vec(&mut self, x: &[T]) {",
      "        for i in x {",
      "            self.push(i.clone());",
      "        }",
      "    }",
      "    pub fn get(&self, x: &T) -> usize {",
      "        self.lower_bound(x)",
      "    }",
      "    pub fn get_vec(&self, x: &[T]) -> Vec<usize> {",
      "        let mut ret = vec![];",
      "        for i in x {",
      "            ret.push(self.get(i))",
      "        }",
      "        ret",
      "    }",
      "    pub fn build(&mut self) {",
      "        self.original.sort();",
      "        self.original.dedup();",
      "    }",
      "    fn lower_bound(&self, x: &T) -> usize {",
      "        let n = self.original.len();",
      "        let mut ng = -1;",
      "        let mut ok = n as isize;",
      "        while ok - ng > 1 {",
      "            let mid = (ok + ng) / 2;",
      "            if *x <= self.original[mid as usize] {",
      "                ok = mid;",
      "            } else {",
      "                ng = mid;",
      "            }",
      "        }",
      "        ok as usize",
      "    }",
      "}",
      "impl<T> Default for CompMap<T>",
      "where",
      "    T: Clone + Ord,",
      "{",
      "    fn default() -> Self {",
      "        Self::new()",
      "    }",
      "}"
    ]
  },
  "LazySegtree": {
    "prefix": "LazySegtree",
    "body": [
      "pub trait ForLazySegtree {",
      "    /// セグ木に乗せるモノイド",
      "    type M: Monoid + Clone;",
      "    /// Lazyに乗せるモノイド",
      "    type L: Monoid + Clone;",
      "    /// モノイドMに対して、Lをどう作用させるか",
      "    fn mapping(m: &Self::M, l: &Self::L) -> Self::M;",
      "}",
      "pub struct LazySegtree<T: ForLazySegtree> {",
      "    original_size: usize,",
      "    leaf_size: usize,",
      "    node: Vec<T::M>,",
      "    lazy: Vec<T::L>,",
      "}",
      "impl<T: ForLazySegtree> LazySegtree<T> {",
      "    pub fn new(n: usize) -> Self {",
      "        let size = n.next_power_of_two();",
      "        LazySegtree {",
      "            original_size: n,",
      "            leaf_size: size,",
      "            node: vec![T::M::e(); 2 * size],",
      "            lazy: vec![T::L::e(); 2 * size],",
      "        }",
      "    }",
      "    pub fn build(&mut self, vec: &[T::M]) {",
      "        for (i, ele) in vec.iter().enumerate() {",
      "            let idx = i + self.leaf_size;",
      "            self.node[idx] = ele.clone();",
      "        }",
      "        for i in (1..self.leaf_size).rev() {",
      "            self.node[i] = self.node[i << 1].op(&self.node[i << 1 | 1])",
      "        }",
      "    }",
      "    pub fn update(&mut self, i: usize, x: T::M) {",
      "        //! 一点更新 O(log N)",
      "        assert!(i < self.original_size);",
      "        let i = i + self.leaf_size;",
      "        self.propagate_above(i);",
      "        self.node[i] = x;",
      "        self.lazy[i] = T::L::e();",
      "        self.recalc_above(i);",
      "    }",
      "    fn range_to_tuple<R>(range: R, r_max: usize) -> (usize, usize)",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        use std::ops::Bound;",
      "        let l = match range.start_bound() {",
      "            Bound::Included(l) => *l,",
      "            Bound::Excluded(l) => l + 1,",
      "            Bound::Unbounded => 0,",
      "        };",
      "        let r = match range.end_bound() {",
      "            Bound::Included(r) => r + 1,",
      "            Bound::Excluded(r) => *r,",
      "            Bound::Unbounded => r_max,",
      "        };",
      "        (l, r)",
      "    }",
      "    pub fn fold<R>(&mut self, range: R) -> T::M",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        //! 区間取得 O(log N)",
      "        let (l, r) = Self::range_to_tuple(range, self.original_size);",
      "        assert!(l < self.original_size);",
      "        assert!(r <= self.original_size);",
      "        let mut l = l + self.leaf_size;",
      "        let mut r = r + self.leaf_size;",
      "        self.propagate_above(l / (l & (!l + 1)));",
      "        self.propagate_above((r / (r & (!r + 1))) - 1);",
      "        let mut vl = T::M::e();",
      "        let mut vr = T::M::e();",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                vl = vl.op(&self.eval_at(l));",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                vr = self.eval_at(r).op(&vr);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        vl.op(&vr)",
      "    }",
      "    pub fn apply_range<R>(&mut self, range: R, a: T::L)",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        //! 区間作用 O(log N)",
      "        let (l, r) = Self::range_to_tuple(range, self.original_size);",
      "        let mut l = l + self.leaf_size;",
      "        let mut r = r + self.leaf_size;",
      "        let l0 = l / (l & (!l + 1));",
      "        let r0 = (r / (r & (!r + 1))) - 1;",
      "        self.propagate_above(l0);",
      "        self.propagate_above(r0);",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                self.lazy[l] = T::L::op(&self.lazy[l], &a);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                self.lazy[r] = T::L::op(&self.lazy[r], &a);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        self.recalc_above(l0);",
      "        self.recalc_above(r0);",
      "    }",
      "    pub fn max_right<F>(&mut self, l: usize, f: F) -> usize",
      "    where",
      "        F: Fn(&T::M) -> bool,",
      "    {",
      "        //! `f(l..r) == true`となる最大のrを探索",
      "        assert!(l <= self.original_size);",
      "        assert!(f(&T::M::e()));",
      "        let mut l = l + self.leaf_size;",
      "        let mut v = T::M::e();",
      "        self.propagate_above(l / (l & (!l + 1)));",
      "        loop {",
      "            while l & 1 != 1 {",
      "                l >>= 1;",
      "            }",
      "            if !f(&v.op(&self.node[l])) {",
      "                while l < self.leaf_size {",
      "                    self.propagate_at(l);",
      "                    l <<= 1;",
      "                    if f(&v.op(&self.node[l])) {",
      "                        v = v.op(&self.node[l]);",
      "                        l += 1;",
      "                    }",
      "                }",
      "                return l - self.leaf_size;",
      "            }",
      "            v = v.op(&self.node[l]);",
      "            l += 1;",
      "            {",
      "                let l = l as isize;",
      "                if l & -l == l {",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "        self.original_size",
      "    }",
      "    pub fn min_left<F>(&mut self, r: usize, f: F) -> usize",
      "    where",
      "        F: Fn(&T::M) -> bool,",
      "    {",
      "        //! `f(l..r) == true`となる最小のlを探索",
      "        assert!(r <= self.original_size);",
      "        assert!(f(&T::M::e()));",
      "        let mut r = r + self.leaf_size;",
      "        let mut v = T::M::e();",
      "        self.propagate_above((r / (r & (!r + 1))) - 1);",
      "        loop {",
      "            r -= 1;",
      "            while r > 1 && r & 1 == 1 {",
      "                r >>= 1;",
      "            }",
      "            if !f(&self.node[r].op(&v)) {",
      "                while r < self.leaf_size {",
      "                    self.propagate_at(r);",
      "                    r <<= 1;",
      "                    r += 1;",
      "                    if f(&self.node[r].op(&v)) {",
      "                        v = self.node[r].op(&v);",
      "                        r -= 1;",
      "                    }",
      "                }",
      "                return r + 1 - self.leaf_size;",
      "            }",
      "            v = self.node[r].op(&v);",
      "            {",
      "                let r = r as isize;",
      "                if r & -r == r {",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "        0",
      "    }",
      "}",
      "impl<T: ForLazySegtree> LazySegtree<T> {",
      "    fn eval_at(&mut self, i: usize) -> T::M {",
      "        //! node[i]にlazy[i]を作用",
      "        T::mapping(&self.node[i], &self.lazy[i])",
      "    }",
      "    fn propagate_at(&mut self, i: usize) {",
      "        //! lazyの合成",
      "        //! 非可換を想定しているので、lazy[i]にあるLをnode[i]に作用させる",
      "        self.node[i] = self.eval_at(i);",
      "        self.lazy[i << 1] = T::L::op(&self.lazy[i << 1], &self.lazy[i]);",
      "        self.lazy[i << 1 | 1] = T::L::op(&self.lazy[i << 1 | 1], &self.lazy[i]);",
      "        self.lazy[i] = T::L::e();",
      "    }",
      "    fn propagate_above(&mut self, i: usize) {",
      "        let h = std::usize::MAX.count_ones() - i.leading_zeros();",
      "        for k in (1..h).rev() {",
      "            self.propagate_at(i >> k);",
      "        }",
      "    }",
      "    fn recalc_above(&mut self, i: usize) {",
      "        let mut i = i;",
      "        while i > 1 {",
      "            i >>= 1;",
      "            self.node[i] = T::M::op(&self.eval_at(i << 1), &self.eval_at(i << 1 | 1))",
      "        }",
      "    }",
      "}"
    ]
  },
  "Monoid": {
    "prefix": "Monoid",
    "body": [
      "pub trait Monoid {",
      "    /// モノイドの二項演算",
      "    fn op(&self, right: &Self) -> Self;",
      "    /// 二項演算の単位元",
      "    fn e() -> Self;",
      "}"
    ]
  },
  "Scc": {
    "prefix": "Scc",
    "body": [
      "/// 強連結成分分解を行う",
      "///",
      "/// `O(|V| + |E|)`",
      "pub struct Scc {",
      "    g: Vec<Vec<usize>>,",
      "    rg: Vec<Vec<usize>>,",
      "    kaerigake: std::cell::RefCell<Vec<usize>>,",
      "    pub dag: Vec<Vec<usize>>,",
      "    pub group_vs: Vec<Vec<usize>>,",
      "}",
      "impl Scc {",
      "    pub fn new(g: Vec<Vec<usize>>) -> Self {",
      "        let mut rg = vec![vec![]; g.len()];",
      "        for v in 0..g.len() {",
      "            for &nv in &g[v] {",
      "                rg[nv].push(v);",
      "            }",
      "        }",
      "        Scc {",
      "            g,",
      "            rg,",
      "            kaerigake: std::cell::RefCell::new(vec![]),",
      "            dag: vec![],",
      "            group_vs: vec![],",
      "        }",
      "    }",
      "    fn dfs(&self, st: usize, seen: &mut Vec<bool>) {",
      "        seen[st] = true;",
      "        for &nv in &self.g[st] {",
      "            if seen[nv] {",
      "                continue;",
      "            }",
      "            self.dfs(nv, seen);",
      "        }",
      "        self.kaerigake.borrow_mut().push(st);",
      "    }",
      "    fn rdfs(&self, st: usize, seen: &mut Vec<bool>, group: &mut Vec<usize>, cnt: usize) {",
      "        seen[st] = true;",
      "        group[st] = cnt;",
      "        for &nv in &self.rg[st] {",
      "            if seen[nv] {",
      "                continue;",
      "            }",
      "            self.rdfs(nv, seen, group, cnt);",
      "        }",
      "    }",
      "    pub fn scc(&mut self) {",
      "        let mut seen = vec![false; self.g.len()];",
      "        for v in 0..self.g.len() {",
      "            if seen[v] {",
      "                continue;",
      "            }",
      "            self.dfs(v, &mut seen);",
      "        }",
      "        seen.fill(false);",
      "        let mut group = vec![usize::MAX; self.g.len()];",
      "        let mut cnt = 0;",
      "        for &v in self.kaerigake.borrow().iter().rev() {",
      "            if seen[v] {",
      "                continue;",
      "            }",
      "            self.rdfs(v, &mut seen, &mut group, cnt);",
      "            cnt += 1;",
      "        }",
      "        self.dag = vec![vec![]; cnt];",
      "        self.group_vs = vec![vec![]; cnt];",
      "        for v in 0..self.g.len() {",
      "            self.group_vs[group[v]].push(v);",
      "            for &nv in &self.g[v] {",
      "                if group[v] == group[nv] {",
      "                    continue;",
      "                }",
      "                self.dag[group[v]].push(group[nv]);",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "Segtree": {
    "prefix": "Segtree",
    "body": [
      "#[derive(Debug)]",
      "pub struct Segtree<T> {",
      "    original_size: usize,",
      "    leaf_size: usize,",
      "    node: Vec<T>,",
      "}",
      "impl<T> Segtree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    pub fn new(n: usize) -> Self {",
      "        let exp = {",
      "            let mut ok: i64 = 41;",
      "            let mut ng: i64 = -1;",
      "            while (ok - ng).abs() > 1 {",
      "                let mid = (ok + ng) / 2;",
      "                if 1 << mid >= n {",
      "                    ok = mid;",
      "                } else {",
      "                    ng = mid;",
      "                }",
      "            }",
      "            ok",
      "        };",
      "        let size = 1 << exp;",
      "        Segtree {",
      "            original_size: n,",
      "            leaf_size: size,",
      "            node: vec![T::e(); 2 * size],",
      "        }",
      "    }",
      "    pub fn build(&mut self, vec: &[T]) {",
      "        for (i, ele) in vec.iter().enumerate() {",
      "            let idx = i + self.leaf_size;",
      "            self.node[idx] = ele.clone();",
      "        }",
      "        for i in (1..self.leaf_size).rev() {",
      "            self.node[i] = self.node[i << 1].op(&self.node[i << 1 | 1])",
      "        }",
      "    }",
      "    pub fn update(&mut self, i: usize, x: T) {",
      "        //! 一点更新 O(logN)",
      "        let mut idx = i + self.leaf_size;",
      "        self.node[idx] = x;",
      "        while idx > 1 {",
      "            idx >>= 1;",
      "            self.node[idx] = self.node[idx << 1].op(&self.node[idx << 1 | 1])",
      "        }",
      "    }",
      "    pub fn add(&mut self, idx: usize, x: T) {",
      "        //! 一点に`x`との二項演算 O(log N)",
      "        let mut idx = idx + self.leaf_size;",
      "        self.node[idx] = self.node[idx].op(&x);",
      "        while idx > 1 {",
      "            idx >>= 1;",
      "            self.node[idx] = self.node[idx << 1].op(&self.node[idx << 1 | 1])",
      "        }",
      "    }",
      "    fn range_to_tuple<R>(range: R, r_max: usize) -> (usize, usize)",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        use std::ops::Bound;",
      "        let l = match range.start_bound() {",
      "            Bound::Included(l) => *l,",
      "            Bound::Excluded(l) => l + 1,",
      "            Bound::Unbounded => 0,",
      "        };",
      "        let r = match range.end_bound() {",
      "            Bound::Included(r) => r + 1,",
      "            Bound::Excluded(r) => *r,",
      "            Bound::Unbounded => r_max,",
      "        };",
      "        (l, r)",
      "    }",
      "    pub fn fold<R>(&self, range: R) -> T",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        //! 区間取得 O(logN)",
      "        let (l, r) = Self::range_to_tuple(range, self.original_size);",
      "        self.query(l, r)",
      "    }",
      "    fn query(&self, l: usize, r: usize) -> T {",
      "        assert!(l < self.original_size);",
      "        assert!(1 <= r && r <= self.original_size);",
      "        let mut l = l + self.leaf_size;",
      "        let mut r = r + self.leaf_size;",
      "        let mut vl = T::e();",
      "        let mut vr = T::e();",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                vl = vl.op(&self.node[l].clone());",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                vr = self.node[r].op(&vr);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        vl.op(&vr)",
      "    }",
      "    pub fn get(&self, idx: usize) -> &T {",
      "        &self.node[idx + self.leaf_size]",
      "    }",
      "    pub fn max_right<F>(&self, mut l: usize, f: F) -> usize",
      "    where",
      "        F: Fn(&T) -> bool,",
      "    {",
      "        //! `f(l..r) == true`となる最大のrを探索",
      "        assert!(l <= self.original_size);",
      "        assert!(f(&T::e()));",
      "        l += self.leaf_size;",
      "        let mut v = T::e();",
      "        loop {",
      "            while l & 1 != 1 {",
      "                l >>= 1;",
      "            }",
      "            if !f(&v.op(&self.node[l])) {",
      "                while l < self.leaf_size {",
      "                    l <<= 1;",
      "                    if f(&v.op(&self.node[l])) {",
      "                        v = v.op(&self.node[l]);",
      "                        l += 1;",
      "                    }",
      "                }",
      "                return l - self.leaf_size;",
      "            }",
      "            v = v.op(&self.node[l]);",
      "            l += 1;",
      "            {",
      "                let l = l as isize;",
      "                if l & -l == l {",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "        self.original_size",
      "    }",
      "    pub fn min_left<F>(&self, mut r: usize, f: F) -> usize",
      "    where",
      "        F: Fn(&T) -> bool,",
      "    {",
      "        //! `f(l..r) == true`となる最小のlを探索",
      "        assert!(r <= self.original_size);",
      "        assert!(f(&T::e()));",
      "        r += self.leaf_size;",
      "        let mut v = T::e();",
      "        loop {",
      "            r -= 1;",
      "            while r > 1 && r & 1 == 1 {",
      "                r >>= 1;",
      "            }",
      "            if !f(&self.node[r].op(&v)) {",
      "                while r < self.leaf_size {",
      "                    r <<= 1;",
      "                    r += 1;",
      "                    if f(&self.node[r].op(&v)) {",
      "                        v = self.node[r].op(&v);",
      "                        r -= 1;",
      "                    }",
      "                }",
      "                return r + 1 - self.leaf_size;",
      "            }",
      "            v = self.node[r].op(&v);",
      "            {",
      "                let r = r as isize;",
      "                if r & -r == r {",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "        0",
      "    }",
      "}"
    ]
  },
  "Trie": {
    "prefix": "Trie",
    "body": [
      "#[derive(Debug, Clone)]",
      "struct TrieNode {",
      "    vertex: Option<char>,",
      "    is_finished: bool,",
      "    common: usize,",
      "    next_verts: std::collections::HashMap<char, TrieNode>,",
      "}",
      "impl TrieNode {",
      "    fn new(c: char, is_finished: bool) -> TrieNode {",
      "        TrieNode {",
      "            vertex: Some(c),",
      "            is_finished,",
      "            common: 0,",
      "            next_verts: std::collections::HashMap::new(),",
      "        }",
      "    }",
      "    fn new_root() -> TrieNode {",
      "        TrieNode {",
      "            vertex: None,",
      "            is_finished: false,",
      "            common: 0,",
      "            next_verts: std::collections::HashMap::new(),",
      "        }",
      "    }",
      "}",
      "#[derive(Debug, Clone)]",
      "pub struct Trie {",
      "    root: TrieNode,",
      "}",
      "impl Trie {",
      "    pub fn new() -> Trie {",
      "        Trie {",
      "            root: TrieNode::new_root(),",
      "        }",
      "    }",
      "    pub fn abc353e(&self, vc: &[char]) -> usize {",
      "        let mut ret = 0;",
      "        let mut current_node = &self.root;",
      "        for c in vc {",
      "            if current_node.next_verts.contains_key(c) {",
      "                current_node = current_node.next_verts.get(c).unwrap();",
      "                eprintln!(\"{:?}: {}\", current_node.vertex, current_node.common);",
      "                ret += current_node.common;",
      "            } else {",
      "                break;",
      "            }",
      "        }",
      "        ret",
      "    }",
      "    pub fn insert(&mut self, vc: &[char]) {",
      "        let mut current_node = &mut self.root;",
      "        for c in vc {",
      "            current_node.common += 1;",
      "            if current_node.next_verts.contains_key(c) {",
      "                current_node = current_node.next_verts.get_mut(c).unwrap();",
      "            } else {",
      "                current_node.next_verts.insert(*c, TrieNode::new(*c, false));",
      "                current_node = current_node.next_verts.get_mut(c).unwrap();",
      "            }",
      "        }",
      "        current_node.common += 1;",
      "        current_node.is_finished = true;",
      "    }",
      "    pub fn contains(&mut self, vc: &[char]) -> bool {",
      "        let mut current_node = &mut self.root;",
      "        for c in vc {",
      "            if current_node.next_verts.contains_key(c) {",
      "                current_node = current_node.next_verts.get_mut(c).unwrap();",
      "            } else {",
      "                return false;",
      "            }",
      "        }",
      "        true",
      "    }",
      "    pub fn lcp(&mut self, vc: &[char]) -> usize {",
      "        let mut current_node = &mut self.root;",
      "        let mut ret = 0;",
      "        for c in vc {",
      "            if current_node.next_verts.contains_key(c) {",
      "                current_node = current_node.next_verts.get_mut(c).unwrap();",
      "                if current_node.common >= 2 {",
      "                    ret += 1",
      "                } else {",
      "                    break;",
      "                }",
      "            } else {",
      "                break;",
      "            }",
      "        }",
      "        ret",
      "    }",
      "}",
      "impl Default for Trie {",
      "    fn default() -> Self {",
      "        Self::new()",
      "    }",
      "}"
    ]
  },
  "UnionFind": {
    "prefix": "UnionFind",
    "body": [
      "pub struct UnionFind {",
      "    v_size: usize,",
      "    par: Vec<i64>,",
      "    siz: Vec<usize>,",
      "    edgecount: Vec<usize>,",
      "}",
      "impl UnionFind {",
      "    pub fn new(n: usize) -> Self {",
      "        UnionFind {",
      "            v_size: n,",
      "            par: vec![-1; n],",
      "            siz: vec![1; n],",
      "            edgecount: vec![0; n],",
      "        }",
      "    }",
      "    pub fn root(&mut self, x: usize) -> usize {",
      "        if self.par[x] == -1 {",
      "            x",
      "        } else {",
      "            self.par[x] = self.root(self.par[x] as usize) as i64;",
      "            self.par[x] as usize",
      "        }",
      "    }",
      "    pub fn unite(&mut self, x: usize, y: usize) -> bool {",
      "        let rx = self.root(x);",
      "        let ry = self.root(y);",
      "        if rx == ry {",
      "            self.edgecount[rx] += 1;",
      "            return false;",
      "        }",
      "        if self.siz[rx] < self.siz[ry] {",
      "            self.par[rx] = ry as i64;",
      "            self.siz[ry] += self.siz[rx];",
      "            self.edgecount[ry] += 1 + self.edgecount[rx];",
      "        } else {",
      "            self.par[ry] = rx as i64;",
      "            self.siz[rx] += self.siz[ry];",
      "            self.edgecount[rx] += 1 + self.edgecount[ry];",
      "        }",
      "        true",
      "    }",
      "    pub fn issame(&mut self, x: usize, y: usize) -> bool {",
      "        if self.root(x) == self.root(y) {",
      "            return true;",
      "        }",
      "        false",
      "    }",
      "    pub fn size(&mut self, x: usize) -> usize {",
      "        let r = self.root(x);",
      "        self.siz[r]",
      "    }",
      "    pub fn edge(&mut self, x: usize) -> usize {",
      "        let r = self.root(x);",
      "        self.edgecount[r]",
      "    }",
      "    pub fn groupcout(&mut self) -> usize {",
      "        let mut dic: std::collections::HashMap<usize, usize> = std::collections::HashMap::new();",
      "        for i in 0..self.v_size {",
      "            let r = self.root(i);",
      "            *dic.entry(r).or_default() += 1;",
      "        }",
      "        let mut ret = 0;",
      "        for value in dic.values() {",
      "            ret = ret.max(*value);",
      "        }",
      "        ret",
      "    }",
      "}"
    ]
  },
  "bellman_ford": {
    "prefix": "bellman_ford",
    "body": [
      "pub fn bellman_ford(st: usize, g: &[Vec<(isize, usize)>]) -> Vec<isize> {",
      "    //! `st`からの単一始点最短路を返す",
      "    //! `(cost, nv)`の隣接リストを要求",
      "    //! 不閉路になるものは`-inf`にして返す",
      "    //! `O(|V| |E|)`",
      "    let n = g.len();",
      "    const INF: isize = isize::MAX;",
      "    const NEG_INF: isize = isize::MIN;",
      "    let mut dist = vec![INF; n];",
      "    dist[st] = 0;",
      "    for _ in 0..n - 1 {",
      "        for v in 0..n {",
      "            if dist[v] == INF {",
      "                continue;",
      "            }",
      "            for (c, nv) in &g[v] {",
      "                if dist[*nv] > dist[v] + c {",
      "                    dist[*nv] = dist[v] + c",
      "                }",
      "            }",
      "        }",
      "    }",
      "    for _ in 0..n {",
      "        for v in 0..n {",
      "            for (c, nv) in &g[v] {",
      "                if dist[*nv] == INF {",
      "                    continue;",
      "                }",
      "                if dist[*nv] > dist[v] + c {",
      "                    dist[*nv] = NEG_INF",
      "                }",
      "            }",
      "        }",
      "    }",
      "    dist",
      "}"
    ]
  },
  "bfs": {
    "prefix": "bfs",
    "body": [
      "pub fn bfs(st: usize, g: &[Vec<usize>]) -> Vec<isize> {",
      "    let n = g.len();",
      "    let mut dist: Vec<isize> = vec![-1; n];",
      "    let mut q = std::collections::VecDeque::new();",
      "    q.push_back(st);",
      "    dist[st] = 0;",
      "    while let Some(v) = q.pop_front() {",
      "        for nv in &g[v] {",
      "            if dist[*nv] != -1 {",
      "                continue;",
      "            }",
      "            dist[*nv] = dist[v] + 1;",
      "            q.push_back(*nv);",
      "        }",
      "    }",
      "    dist",
      "}"
    ]
  },
  "dfs": {
    "prefix": "dfs",
    "body": [
      "pub fn dfs(v: usize, p: usize, g: &[Vec<usize>]) {",
      "    for nv in &g[v] {",
      "        if p == *nv {",
      "            continue;",
      "        }",
      "        dfs(*nv, p, g);",
      "    }",
      "}"
    ]
  },
  "dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "pub fn dijkstra(st: usize, g: &[Vec<(usize, usize)>]) -> Vec<usize> {",
      "    //! 単一始点最短路を求める",
      "    //! `(cost, nv)`の隣接リストを要求",
      "    //! `O(|E|log|V|)`",
      "    use std::cmp::Reverse;",
      "    let n = g.len();",
      "    let inf: usize = 1 << 60;",
      "    let mut kakutei = vec![false; n];",
      "    let mut dist = vec![inf; n];",
      "    let mut pq = std::collections::BinaryHeap::new();",
      "    dist[st] = 0;",
      "    pq.push(Reverse((dist[st], st)));",
      "    while let Some(Reverse((_, v))) = pq.pop() {",
      "        if kakutei[v] {",
      "            continue;",
      "        }",
      "        kakutei[v] = true;",
      "        for (ncos, nv) in &g[v] {",
      "            if dist[*nv] > dist[v] + ncos {",
      "                dist[*nv] = dist[v] + ncos;",
      "                pq.push(Reverse((dist[*nv], *nv)))",
      "            }",
      "        }",
      "    }",
      "    dist",
      "}"
    ]
  },
  "kruskal": {
    "prefix": "kruskal",
    "body": [
      "pub fn kruskal(mut e: Vec<(isize, usize, usize)>, n: usize) -> (Vec<(isize, usize, usize)>, isize) {",
      "    //! 最小全域木に入る辺と両端点、総コストを返す",
      "    //! `(cost, v, nv)`の隣接リスト",
      "    //! `O(|E|log|E|)`",
      "    e.sort();",
      "    let mut uf = UnionFind::new(n);",
      "    let mut ans_cost = 0;",
      "    let mut ans_e = vec![];",
      "    for (c, v, u) in e {",
      "        if uf.issame(v, u) {",
      "            continue;",
      "        }",
      "        uf.unite(v, u);",
      "        ans_cost += c;",
      "        ans_e.push((c, v, u));",
      "    }",
      "    (ans_e, ans_cost)",
      "}"
    ]
  },
  "lcm/gcd": {
    "prefix": "lcm/gcd",
    "body": [
      "pub fn gcd(a: usize, b: usize) -> usize {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "pub fn lcm(a: usize, b: usize) -> usize {",
      "    (a / gcd(a, b)) * b",
      "}"
    ]
  },
  "modinv": {
    "prefix": "modinv",
    "body": [
      "pub fn modinv(mut a: isize, m: isize) -> isize {",
      "    //! `a mod m`の逆元",
      "    //! `a`と`m`の互いが素を仮定",
      "    let mut b = m;",
      "    let mut u = 1;",
      "    let mut v = 0;",
      "    while b > 0 {",
      "        let t = a.div_euclid(b);",
      "        a -= t * b;",
      "        (a, b) = (b, a);",
      "        u -= t * v;",
      "        (u, v) = (v, u);",
      "    }",
      "    u = u.rem_euclid(m);",
      "    u",
      "}"
    ]
  },
  "warshall_froyd": {
    "prefix": "warshall_froyd",
    "body": [
      "pub fn warshall_froyd(g: &[Vec<(isize, usize)>]) {",
      "    //! 全始点最短路",
      "    //! `(cost, nv)`のの隣接リスト",
      "    //! `O(|V|^3)`",
      "    const INF: isize = isize::MAX;",
      "    let n = g.len();",
      "    let mut dist = vec![vec![INF; g.len()]; g.len()];",
      "    for v in 0..n {",
      "        for &(cost, nv) in &g[v] {",
      "            dist[v][nv] = isize::min(dist[v][nv], cost);",
      "        }",
      "    }",
      "    for k in 0..n {",
      "        for i in 0..n {",
      "            for j in 0..n {",
      "                dist[i][j] = dist[i][j].min(dist[i][k] + dist[k][j])",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  }